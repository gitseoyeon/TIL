# 컴퓨터 구조

# 01. 컴퓨터 구조 시작하기

## 컴퓨터 구조 큰 그림

- 컴퓨터 구조
    - 컴퓨터가 이해하는 정보
        - 데이터 : 컴퓨터가 이해하는 숫자, 문자, 이미지, 동영상과 같은 정적인 정보 (0, 1)
        - 명령어 : 데이터를 움직이고 컴퓨터를 작동시키는 정보
    - 컴퓨터의 네 가지 핵심 부품
        - CPU
        - 메모리 (주기억장치)
        - 보조기억장치
        - 입출력장치
### 메모리

- 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품
- 프로그램이 실행되려면 반드시 메모리에 저장되어 있어야함
- **주소**
    - 메모리에 저장된 값에 빠르고 효율적으로 접근하기 위한 것
    - 컴퓨터에서 주소로 원하는 위치에 접근 가능함

### CPU

- 컴퓨터의 두뇌
- 메모리에 저장된 명령어를 읽어 들이고 읽어 들인 명령어를 해석하고 실행하는 부품
- CPU 내부 구성 요소
    - **산술논리연산 장치 (ALU)**
        - 계산기 역할
        - 컴퓨터 내부에서 수행되는 대부분의 계산을 함
    - **레지스터 (Resister)**
        - CPU 내부의 작은 임시 저장 장치
        - 프로그램을 실행하는 데 필요한 값들을 임시로 저장함
        - 여러 개의 레지스터가 존재하며 각기 다른 이름과 역할을 가지고 있음
    - **제어장치 (CU)**
        - 제어신호라는 전기신호를 보내고 명령어를 해석하는 장치
            - 제어신호 : 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호
        - CPU가 메모리에 저장된 값을 읽고 싶을때 → 메모리를 향해 메모리 읽기 제어 신호 보냄
        - CPU가 메모리에 어떤 값을 저장하고 싶을때 → 메모리를 향해 메모리 쓰기 제어 신호 보냄

### 보조기억장치

- 메모리(주기억장치) 의 단점
    - 가격이 비싸 저장 용량이 적다
    - 전원이 꺼지면 저장된 내용을 잃는다.
- 위의 단점을 보안하기 위해 만든것이 보조기억장치
- **메모리가 크고 전원이 꺼져도 저장된 내용을 잃지 않는 메모리**
- 하드디스크, SSD, USB 메모리, DVD, CD-ROM 등

### 입출력장치

- 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치
- 마이크, 스피커 프린터, 마우스, 키보드 등

### 메인보드와 시스템 버스

- 메인보드 (마더보드)
    - 지금까지 설명한 컴퓨터의 핵심 부품들
    - 여러 컴퓨터 부품을 부착할 수 있는 슬롯과 연결 단자가 있음
- 시스템 버스
    - 버스 : 메인보드에 연결된 부품들을 서로 정보를 주고 받게 하는 것
    - **여러 버스 가운데 네가지 핵심 부품을 연결하는 가장 중요한 버스**
    - 주소 버스
        - 주소를 주고 받는 통로
    - 데이터 버스
        - 명령어와 데이터를 주고 받는 통로
    - 제어 버스
        - 제어 신호를 주고 받는 통로

# 02. 데이터

## 0과 1로 숫자를 표현하는 방법

### 정보 단위

- 비트 (bit)
    - 0과 1을 나타내는 가장 작은 정보 단위
    - n 비트는 2^n 가지 정보를 표현 할 수 있음
- 바이트 (byte)
    - 여덟개의 비트를 묶은 단위
    - 1byte = 8bit = 2^8 (256)개 정보
- 킬로바이트 (kB)
    - 1000 바이트를 묶은 단위
- 메가바이트 (MB)
    - 1000 킬로바이트를 묶은 단위
- 기가바이트 (GB)
    - 1000 메가바이트를 묶은 단위
- 테라바이트 (TB)
    - 1000 기가바이트를 묶은 단위
- 워드
    - CPU가 한 번에 처리할 수 있는 데이터 크기
    - 워드의 절반 크기 (하프워드), 1배 크기 (풀 워드), 2배 크기 (더블 워드)

### 이진법

- 0과 1만으로 모든 숫자를 표현하는 방법
- 십진법
    - 숫자가 9를 넘어가는 시점에 자리올림을 해서 0부터 9까지 열개의 숫자만으로 모든 수를 표현하는 방법
- 이진수 → 이진법으로 표현한 수, 십진수 → 십진법으로 표현한 수
- 이진수의 음수 표현
    - 2의 보수
        - 0과 1만으로 음수를 표현하는 방법
        - 어떤 수를 그보다 큰 2^n 에서 뺀 값
        - 모든 0과 1을 뒤집고(1의 보수) 거기에 1을 더한 값(2의 보수)
    - 플래그
        - 실제 이진수를 보고 음수인지 양수인지 구분하기 위한 것

### 십육진법

- 이진법을 사용하면 숫자의 길이가 너무 길어진다는 단점이 있어 십육진법을 사용함
- 수가 15를 넘어가는 시점에 자리 올림을 하는 숫자 표현 방식
- 10-15를 A, B, C, D, E, F로 표기함

### 십육진수를 이진수로 표현하기

- 1A2B = 0001 1010 0010 1011
    - 1 = 0001
    - A = 10 = 1010
    - 2 = 0010
    - B = 1011

### 이진수를 십육진수로 변환하기

- 11010101 = D5
    - 1101 = 13 = D
    - 0101 = 5

## 0과 1로 문자를 표현하는 방법

### 문자집합과 인코딩

- 문자집합
    - 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
    - 컴퓨터는 문자 집합에 속해 있는 문자를 이해할 수 있음
- 문자 인코딩
    - 문자를 0과 1로 변환 하는 것
    - 같은 문자 집합에 대해서도 다양한 인코딩 방법이 있음
- 문자 디코딩
    - 인코딩의 반대 과정
    - 0과 1로 이루어진 문자코드를 사람이 이해 할 수 있는 문자로 변환하는 과정

### 아스키 코드

- 아스키
    - 초창기 문자 집합중 하나
    - 영어 알파벳과 아라비아 숫자, 그리고 일부 특수 문자를 포함함
    - 아스키 문자들을 각각 7비트로 표현되는데 7비트로 표현할 수 있는 정보의 가짓수는 2^7개로 총 128개의 문자를 표현할 수 있음
        - 실제로는 아스키 문자를 사용하는데 8비트를 사용함.
        - 8비트 중 1비트는 오류를 검출하기 위해 사용되는 패리티 비트이기 때문에 실질적으로 문자 표현을 위해 사용되는 비트는 7비트이다.
- 아스키 코드
    - 아스키 문자에 대응된 고유한 수
    - 아스키 문자는 아스키 코드로 인코딩 됨
    - 한글, 아스키 문자 집합 외의 문자, 특수문자를 표현 할 수 없다는 단점이 있음

### EUC-KR

- 한글 인코딩 방식
    - 완성형 인코딩
        - 초성, 중성, 종성의 조합으로 이루어진 완성된 하나의 글자에 고유한 코드를 부여하는 인코딩 방식
    - 조합형 인코딩
        - 초성을 위한 비트열, 중성을 위한 비트열, 종성을 위한 비트열을 할당하여 그것들의 조합으로 하나의 글자 코드를 완성하는 인코딩 방식
- KS X 1001, KS X 1003이라는 문자 집합을 기반으로 하는 대표적인 완성형 인코딩 방식
- 초성, 중성, 종성 모두 결합된 단어에 2바이트 크기의 코드를 부여 = 한 글자당 16비트
- CP949
    - EUC-KR 인코딩의 단점을 해결하기 위해 나온 코드

### 유니코드와 UTF-8

- 유니코드
    - 모든 나라 언어의 문자 집합과 인코딩 방식이 통일된 인코딩 방식
    - EUC-KR 보다 훨씬 다양한 한글을 포함함
    - 유니코드는 글자에 부여된 값 자체를 인코딩된 값으로 삼지 않고 다양한 방법으로 인코딩 함
        - UTF-8, UTF-16, UTF-32 등
- UTF-8
    - 1바이트부터 4바이트까지의 인코딩 결과를 만들어 냄

# 03  명령어

## 소스코드와 명령어

### 고급언어와 저급 언어

- 고급언어
    - 사람을 위한 언어
    - 프로그래밍 언어
- 저급언어
    - 컴퓨터가 직접 이해하고 실행할 수 있는 언어
    - 기계어
        - 0과 1의 명령어 비트로 이루어진 언어
    - 어셈블리어
        - 기계어를 읽기 편한 형태로 번역한 언어
            - 0101 0101 → push rbp
- 고급언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어(명령어) 로 실행 되어야한다.

### 컴파일 언어와 인터프리터 언어

- 고급언어
    - 컴파일언어
        - 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어
        - 대표 컴파일 언어는 C언어
        - 컴파일
            - 컴파일 언어로 작성된 소스코드는 코드 전체가 저급 언어로 변환되는 과정
        - 컴파일러
            - 컴파일을 수행해 주는 도구
        - 목적코드(object code)
            - 컴파일러를 통해 저급 언어로 변환된 코드
    - 인터프리터 언어
        - 인터프리터에 의해 소스코드가 한 줄씩 실행되는 고급 언어
        - 대표 인터프리터 언어는 python
        - 인터프리터
            - 소스코드를 한 줄씩 저급 언어로 변환하여 실행해 주는 도구
- 목적파일과 실행파일
    - 목적 파일
        - 목적 코드로 이루어진 파일
        - 목적 코드가 실행 파일이 되려면 링킹이라는 작업을 가져야 함
            - 링킹
                - 어떤 목적 코드와 다른 목적 코드를 연결 하는 작업
    - 실행 파일
        - 실행 코드로 이루어진 파일
        - 윈도우의 .exe 확장자를 가진 파일

## 명령어의 구조

### 연산 코드와 오퍼랜드

- 명령어
    - 연산 코드 (operation code)
        - 명령어가 수행할 연산
        - 연산 코드 필드 : 연산 코드가 담기는 영역
        - 연산 코드 유형
            - 데이터 전송
                - MOVE : 데이터를 옮겨라
                - STORE : 메모리에 저장하라
                - LOAD (FETCH) : 메모리에서 CPU로 데이터를 가져와라
                - PUSH : 스택에 데이터를 저장하라
                - POP : 스택의 최상단 데이터를 가져와라
            - 산술/논리 연산
                - ADD / SUBSTRACT / MULTIPLY / DIVIDE : 덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행
                - INCREMENT / DECREMENT : 오퍼램드에 1을 더하라 / 오퍼랜드에 1을 빼라
                - AND / OR / NOT : AND / OR / NOT 연산을 수행하라
                - COMPARE : 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라
            - 제어 흐름 변경
                - JUMP : 특정 주소로 실행 순서를 옮겨라
                - CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
                - HALT : 프로그램의 실행을 멈춰라
                - CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
                - RETURN : CALL 을 호출할 때 저장했던 주소로 돌아가라
            - 입출력 제어
                - READ (INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
                - WRITE (OUTPUT) : 특정 입출력 장치로 데이터를 써라
                - START IO : 입출력 장치를 시작하라
                - TEST IO : 입출력 장치의 상태를 확인하라
    - 오퍼랜드 (operand)
        - 연산에 사용할 데이터가 저장된 위치
        - 오퍼랜드 필드 (주소 필드)
            - 오퍼랜드가 담기는 영역
            - 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 온다.
            - 많은 경우 사용할 데이터가 저장된 위치 (메모리 주소, 레지스터 이름) 이 담김.
        - 0-주소 명령어
            - 오퍼랜드가 하나도 없는 명령어
        - 1-주소 명령어
            - 오퍼랜드가 하나인 명령어
        - 2-주소 명령어
            - 오퍼랜드가 두개인 명령어
        - 3-주소 명령어
            - 오퍼랜드가 세개인 명령어

### 주소 지정 방식

- 유효 주소 (effective address)
    - 연산의 대상이 되는 데이터가 저장된 위치
- 주소 지정 방식
    - 오퍼랜드 필드에 데이터가 저장된 위치를 명시 할 때 연산에 사용할 데이터 위치를 찾는 방법
    - 유효 주소를 찾는 방법
    - 대표적인 주소 지정 방식
        - 즉시 주소 지정 방식
            - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
            - 데이터의 크기가 작아진다는 단점이 있음
            - 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 빠르다.
        - 직접 주소 지정 방식
            - 오프랜드 필드에 유효 주소를 직접적으로 명시하는 방식
        - 간접 주소 지정 방식
            - 유효 주소의 주소를 오퍼랜드 필드에 명시
            - 두번의 메모리 접근이 필요하기 때문에 느린 방식.
        - 레지스터 주소 지정 방식
            - 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법
            - 메모리에 접근하는 것보다 레지스터에 접근하는 것이 더 빠름
            - 표현할 수 있는 레지스터 크기에 제한이 생김
        - 레지스터 간접 주소 지정 방식
            - 연산에 사용할 데이터를 메모리에 저장하고 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법
            - 메모리 접근 횟수가 한번으로 줄어들기 때문에 간접 주소 지정 방식보다 빠르다
- 스택과 큐
    - 스택
        - 한쪽 끝이 막혀있는 통과 같은 저장공간
        - 데이터를 저장할때는 차곡 차곡 저장하고 자료를 빼낼 때는 마지막으로 데이터부터 뺀다
        - LIFO 방식 (후입선출)
        - PUSH : 스택에 데이터를 저장하는 명령어
        - POP : 스택에 저장된 데이터를 꺼내는 명령어
    - 큐
        - 스택과는 달리 양쪽이 뚫려 있는 통과 같은 저장공간
        - 한쪽으로 데이터 저장하고 다른 한쪽으로는 먼저 저장한 순서대로 데이터를 뺀다.
        - FIFO 방식 (선입선출)