## 2과목 - 3장 [ SQL 최적화 기본 원리 ]

### ■ 옵티마이저 종류

- **비용 기반 옵티마이저 (CBO)**
    - 소요될 처리시간 및 CPU, I/O 자원량 등을 계산해서 가장 효율적일 것으로 예상되는 실행 계획을 선택하는 옵티마이저
    - SQL을 수행하는데 있어 소요되는 비용을 계산하여 실행 계획을 생성하므로 인덱스가 존재하더라도 전체 테이블이 유리하다고 판단될 수 있음
    - 테이블, 인덱스, 칼럼 등 객체의 통계정보를 사용하여 실행 계획을 수립하므로 통계정보가 변경되면 SQL의 실행계획이 달라질 수 있음
- **규칙 기반 옵티마이저**
    - 우선순위 규칙에 따라 실행 계획 생성, 인덱스가 있으면 반드시 인덱스 사용
    - 적절한 인덱스가 존재하면 항상 인덱스를 사용하려고 함
    - 우선순위가 높은 규칙은 Single row by rowid 엑세스 기법임

### ■ 실행 계획

- SQL 처리를 위한 실행 절차와 방법을 표현한 것
- 알 수 있는 정보
    - 액세스 기법
    - 질의 처리 예상 비용
    - 조인 순서
- 구성 요소
    - 조인기법
    - 연산
    - 최적화 정보
    - 액세스 기법

### ■ SQL 처리 흐름도

- 인덱스 스캔, 테이블 전체 스캔 등과 같은 액세스 기법이 표현
- 성능적인 측면도 표현할 수 있음
- SQL의 내부적인 처리 절차를 시각적으로 표현
- SQL의 실행 시간을 알 수 없음

### ■ 인덱스

- 인덱스는 인덱스 구성 칼럼으로 항상 내림차순 정렬 됨
- 기본 인덱스는 UNIQUE & NOT NULL 의 제약조건을 가짐
- 보조 인덱스는 UNIQUE 인덱스가 아니라면 중복 데이터의 입력 가능
- 인덱스는 조회, 삽입, 삭제, 갱신 연산의 속도를 지연시킴
    - UPDATE 는 부하가 없을 수도 있음
- 테이블의 전체 데이터를 읽는 경우는 인덱스가 거의 불필요함
- 대량의 데이터를 삽입할 때는 모든 인덱스를 제거하고 데이터를 입력하는 것이 좋음
- B-TREE 인덱스
    - 브랜치 블록과 리프 블록으로 구성
    - 브랜치 블록
        - 분기를 목적으로 함
    - 리프 블록
        - 인덱스를 구성하는 칼럼의 값으로 정렬
        - 일반적으로 OLTP 시스템 환경에서 가장 많이 사용됨
- CLUSTERED 인덱스
    - 인덱스의 리프페이지가 곧 데이터 페이지이며 리프페이지의 모든 데이터는 인덱스 키 컬럼 순으로 물리적으로 정렬되어 저장됨
- BITMAP 인덱스
    - 시스템에서 사용될 질의를 시스템 구현시에 모두 알 수 없는 경우인 DW 및 AC-HOC 질의 환경을 위해서 설계 되었으며 하나의 인덱스 키 엔트리가 많은 행에 대한 포인터를 저장하고 있는 구조
- 클러스터형 인덱스
    - oracle의 IOT와 매우 유사함

### ■ JOIN

- Nested Loop Join
    - 조인 칼럼에 적당한 인덱스가 있어서 자연조인이 효율적일 때 유용함
    - Driving Table의 조인 데이터 양이 큰 영향을 주는 조인 방식임
    - 유니크 인덱스를 활용하여 수행시간이 적게 걸리는 소량 테이블을 온라인 조회하는 경우 유용
    - 선택도가 낮은 테이블이 선행 테이블로 선택되는 것이 일반적으로 유리
- Hash Join
    - 소트 머지 조인을 하기에 두 테이블이 너무 커서 소트부하가 심할 때 유용
    - 조인 칼럼의 인덱스를 사용하지 않기 때문에 조인 칼럼의 인덱스가 존재하지 않을 경우 사용할 수 있는 조인 기법
- Sort Merge Join
    - 조인 칼럼에 적당한 인덱스가 없어서 NL 조인이 비효율적일 때 사용할 수 있음
    - Driving Table의 개념이 중요하지 않은 조인 방식
    - 조인 조건의 인덱스의 유무에 영향 받지 않음