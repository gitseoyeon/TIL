# SQLD

# 오답 정리

## 1과목 - 1장 [ 데이터 모델링의 이해 ]

### ■ 모델링의 특징

- **추상화**
- **단순화**
- **정확화**
- **시스템 구현, 업무 분석 및 업무 형성화**를 위해 진행함

### ■ 데이터모델링을 할 때 유의해야 할 사항

- **중복성 최소화**
- **데이터 정의를 데이터의 사용 프로세스와 분리**하여 유연성을 높임 (**비유연성**)
- **비일관성**

### ■ 데이터모델링 개념

- **개념적 데이터 모델링**
    - **추상화 수준이 높고** **업무 중심적**이고 **포괄적인 수준**의 모델링 진행
    - 전사적 데이터 모델링, EA 수립시 많이 사용
- **논리적 데이터 모델링**
    - 시스템으로 구축하고자 하는 업무에 대해 **Key, 속성, 관계 등을 정확하게 표현**, **재사용성**이 높음
- **물리적 데이터 모델링**
    - **실제로 데이터 베이스에 이식**할 수 있도록 성능, 저장 등 물리적인 성격을 고려하여 설계

### ■ 스키마 3단계 구조

- **외부 스키마**
- **개념 스키마**
    - **모든 사용자 관점을 통합**한 조직 전체 관점의 통합적 표현
    - DB에 저장되는 데이터와 그들간의 관계를 표현하는 스키마
- **내부 스키마**

### ■ ERD

- **피터첸**에 의해 만들어짐
- 작성 순서
    - 엔터티 **도출**
    - 엔터티 **배치**
    - **관계 설정**
    - **관계명 기술**
- 가장 중요한 엔터티를 **왼쪽 상단**에 배치

### ■ 엔터티의 특징

- 반드시 **속성을 가지고 있어야함**
- 엔터티는 **다른 엔터티와 관계가 반드시 있음**. 단 통계선 엔터티나, 코드성 엔터티의 경우 관계를 생략할 수 있음
- 엔터티는 **두개 이상의 인스턴스**를 가지고 있어야함
- 해당 업무에서 관리하고자하는 업무여야함
- 유일한 식별자에 의해 **식별이 가능해야함**

### ■ 엔터티의 이름 부여하는 방법

- **약어를 사용하지 않는 것이 좋음**
- **현업의 업무 용어**를 사용
- 모든 엔터티에서 **유일한 이름이 부여**되어야함
- 엔터티가 생성되는 의미대로 **자연스럽게 부여**

### ■ 속성

- 업무에서 필요로 하는 인스턴스에서 관리하고자 하는 **의미상 더 이상 분리되지 않는 최소의 데이터 단위**

### ■ 속성에 대한 설명

- **엔터티에 대한 자세하고 구체적인 정보**를 나타냄
- 하나의 **엔터티는 두 개 이상의 속성**을 가짐
- 속성도 집함임

### ■ 파생 속성

- 데이터를 조회할 때 빠른 성능을 낼 수 있도록 하기 위해 **원래 속성의 값을 계산하여 저장할 수 있도록 만든 속성**

### ■ 도메인

- **각 속성이 가질 수 있는 값의 범위**
- 엔티티 내에서 **속성에 대한 데이터 타입과 크기 그리고 제약사항을 지정**

### ■ 데이터모델링의 관계

- 관계는 **존재에 의한 관계**와 **행위에 의한 관계**로 구분
- ERD 에서는 관계를 연결할 때 존재와 행위를 구분하지 않고 단일화 된 표기법 사용
- UML에는 클래스다이어그램의 관계 중 **연관관계**와 **의존관계**가 있고 이것은 실선과 점선의 표기법으로 다르게 표현

### ■ 관계

- 관계는 **존재적 관계**와 **행위에 의한 관계**로 나누어 볼 수 있음
- 관계의 표기법은 **관계명, 관계차수, 선택성** 개념을 사용
    - 관계명 : 관계의 이름
    - 관계 차수 : 1:1, 1:M, M:N
    - 관계 선택사양 : 필수관계, 선택관

### ■ 두 개의 엔터티 사이에 정의한 관계 체크 사항

- 두 개의 엔터티 사이에 관심있는 연관 규칙이 존재하는가
- 두 개의 엔터티 사이에 정보의 조합이 발생하는가
- 관계 연결에 대한 규칙이 서술되어 있는가
- 관계 연결을 가능하게 하는 동사가 있는가

### ■ 주식별자의 특징

- 유일성
    - 주식별자에 의해 엔터티 내에 모든 인스턴스들을 유일하게 구별
- 최소성
    - 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야함
- 불변성
    - 주식별자가 한 번 특정 엔터티에 지정되면 그 식별자의 값은 변하지 않아야함
- 존재성
    - 주식별자가 지정되면 반드시 데이터 값이 존재해야함

### ■ 식별자와 비식별자

- 식별자 관계
    - 목적 : 강한 연결관계 표현
    - 자식 주식별자 영향 : 자식 주식별자의 구성에 포함됨
    - 표기법 : 실선 표현
    - 연결 고려사항
        - 반드시 부모엔터티 종속
        - 자식 주식별자구성에 부모 주식별자 포함 필요
        - 상속받은 주식별자 속성을 타엔터티에 이전 필요
- 비식별자 관계
    - 목적 : 약한 연결관계 표현
    - 자식 주식별자 영향 : 자식 일반 속성에 포함됨
    - 표기법 : 점선 표현
    - 연결 고려사항
        - 약한 종속관계
        - 자식 주식별자구성을 독립적으로 구성
        - 자식 주식별자구성에 부모 주식별자 부분 필요
        - 상속받은 주식별자속성을 타 엔터티에 차단 필요
        - 부모쪽의 관계 참여가 선택 관계

### ■ 식별자의 분류체계

- 대표성 여부
    - 주식별자
        - 엔터티 내에서 각 어커런스를 구분할 수 있는 구분자
    - 보조식별자
        - 엔터티 내에서 각 어커런스를 구분할 수 있는 구분자이나 대표성을 가지지 못해 참조 관계 연결을 못함
- 스스로 생성 여부
    - 내부식별자
        - 엔터티 내부에서 스스로 만들어지는 식별자
    - 외부식별자
        - 타 엔터티와 관계를 통해 타 엔터티로부터 받아오는 식별자
- 속성의 수
    - 단일식별자
        - 하나의 속성으로 구성된 식별자
    - 복합식별자
        - 둘 이상의 속성으로 구성된 식별자
- 대체 여부
    - 본질식별자
        - 업무에 의해 만들어지는 식별자
    - 인조식별자
        - 업무적으로 만들어지지는 않지만 원조 식별자가 복잡한 구성을 가지고 있기 때문에 인위적으로 만든 식별자

## 1과목 - 2장 [ 데이터 모델과 성능 ]

### ■ 성능데이터모델링

- 데이터베이스 성능 향상 목적으로 설계 단계의 데이터 모델링 때부터 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것
- 데이터의 증가가 빠를수록 성능저하에 따른 성능 개선 비용은 증가함
- 데이터모델은 성능을 튜닝하면서 변경이 될 수 있는 특징이 있음
- **분석/설계 단계에서 성능을 고려한 데이터모델링을 수행할 경우** 성능 저하에 따른 Rework 비용을 최소화 할 수 있는 기회를 가지게 됨

### ■ 데이터 모델링의 순서

1. 데이터모델링을 할 때 **정규화**를 정확하게 수행함
2. 데이터베이스 **용량산정**을 수행함
3. 데이터베이스에 발생되는 **트랜잭션의 유형을 파악**
4. 용량과 트랜잭션의 유형에 따라 **반정규화**를 수행
5. **이력모델의 조정**, **PK/FK 조정**, **슈퍼타입/서브타입 조정** 등을 수행

### ■ 성능데이터모델링을 할 때 고려사항

- 용량산정은 전체적인 데이터베이스에 발생되는 **트랜잭션의 유형과 양을 분석하는 자료**임
- 물리적인 데이터 모델링을 할 때 **PK/FK의 칼럼의 순서조정, FK 인덱스 생성** 등은 중요한 요소임
- 이력 데이터는 시간에 따라 반복적으로 발생이 되기 때문에 대량 데이터일 가능성이 높아 특별히 성능을 고려하여 칼럼 등을 추가하도록 설계해야함

### ■ 반정규화

- 반정규화는 **정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행**하는 데이터 모델링의 기법을 의미
- 데이터를 중복하여 성능을 향상시키기 위한 기법
- 성능을 향상시키기 위해 **정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정**
- 반정규화 적용 이유
    - 데이터를 조회할 때 디스크 I/O 량이 많아서 성능이 저하되거나 경로가 너무 멀어 **조인으로 인한 성능저하 예상 될 때**
    - 칼럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우
- 반정규화 기법
    - 테이블의 반정규화
        - 테이블 병합
            - 1:1 관계 테이블 병합
            - 1:M 관계 테이블 병합
            - 슈퍼/서브타입 테이블 병합
        - 테이블 분할
            - 수직분할
            - 수평분할
        - 테이블 추가
            - 중복테이블 추가
            - 통계테이블 추가
            - 이력테이블 추가
            - 부분테이블 추가
    - 칼럼의 반정규화
        - 중복칼럼 추가
            - 조인 감소를 위해 여러 테이블에 동일한 칼럼을 갖도록 함
        - 파생칼럼 추가
            - 조회 성능을 우수하게 하기 위해 미리 계산된 칼럼을 갖도록 함
        - 이력테이블 칼럼 추가
            - 최신값을 처리하는 이력의 특성을 고려하여 기능성 칼럼을 추가함
        - PK에 의한 칼럼 추가
        - 응용 시스템 오작동을 위한 칼럼 추가

### ■ 반정규화 대상에 대해 다른 방법으로 처리

- 뷰 사용
    - 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우
- 클러스터링/인덱스 조정
    - 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우
- 파티셔닝 기법
    - 대량의 데이터는 Primary Key의 성격에 따라 부분적인 테이블로 분리할 수 있음
    - 논리적으로는 하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리하여 데이터 액세스 성능도 향상시키고 데이터 관리 방법도 개선할 수 있도록 테이블에 적용하는 기법

### ■ 슈퍼/서브 타입 데이터 모델의 변환 기술

- 개별적으로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성
- 슈퍼 타입 + 서브 타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입 + 서브타입 테이블로 구성
- 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성

## 2과목 - 1장 [ SQL 기본 ]

### ■ SQL 문장들의 종류

- 데이터 조작어 (DML)
    - 데이터베이스 사용자가 응용 프로그램이나 질의어를 통하여 저장된 데이터베이스를 실질적으로 접근하는데 사용
    - 비절차적 데이터 조작어로 사용자가 무슨 데이터를 원하는지 명세하는 언어
    - 호스트 프로그램 속에 삽입되어 사용되는 DML 명령어들을 데이터 부속어라고 함
    - SELECT
    - INSERT
    - UPDATE
    - DELETE
- 데이터 정의어 (DDL)
    - 테이블 구조를 생성, 변경, 삭제하는 등 데이터 구조를 정의하는데 사용되는 명령어
    - CREATE
    - ALTER
    - DROP
    - RENAME
- 데이터 제어어 (DCL)
    - 데이터베이스에 접근하고 객체들을 사용하도록 권한을 주고 회수하는 명렁어
    - GRANT
    - REVOKE
- 트랜잭션 제어어 (TCL)
    - 논리적인 작업의 단위를 묶어 DML에 의해 조작된 결과를 작업 단위별로 제어하는 명령어
    - COMMIT
    - ROLLBACK

### ■ 데이터 언어와 SQL 명령어

- 데이터 언어
    - 데이터베이스를 정의하고 접근하기 위해서는 데이터베이스 관리 시스템과의 통신수단

### ■ ALTER 명령문

```java
CREATE TABLE 테이블명
( 필드명 필드데이터타입 NOT NULL // PRIMARY KEY
 ,필드명 필드데이터타입 NULL 여부
 ,CONSTRAINT 테이블명_PK PRIMARY KEY (필드명) );
```

- SQLServer 에서는 여러개의 컬럼을 동시에 수정하는 구문은 지원하지 않음

### ■ 제약조건

- PRIMARY KEY
    - UNIQUE + NOT NULL
- UNIQUE KEY
    - 고유키
    - 테이블 내에서 중복되는 값이 없지만 NULL 입력이 가능함
- FK
- NOT NULL

### ■ 테이블의 불필요한 칼럼 삭제

```java
ALTER TABLE 테이블명
DROP COLUMN 삭제할 컬럼명;
```

### ■ 테이블 이름 이름 변경 SQL

```java
RENAME 기존 테이블명 TO 변경할 테이블명;
```

### ■ 참조 동작

- CASCADE
    - Master 삭제 시 Child 같이 삭제
- RESTRICT
    - Child 테이블에 PK 값이 없는 경우만 Master 삭제 허용
- AUTOMATIC
    - Master 테이블에 PK가 없는 경우 Master PK를 생성 후 Child 입력
- DEPENDENT
    - Master 테이블에 PK가 존재할 때만 Child 입력 허용

### ■ 테이블에 데이터를 입력하는 유형

```java
INSERT INTO 테이블명
	(COLUMN_LIST)
	VALUES
	(COLUMN_LIST에 넣을 VALUE_LIST);
```

```java
INSERT INTO 테이블명
	VALUES
	(전체 COLUMN에 넣을 VALUE_LIST);
```

### ■ 입력된 데이터 수정

```java
UPDATE 테이블명
SET 수정되어야 할 칼럼명 = 수정되기를 원하는 새로운 값;
```

### ■ 테이블의 데이터 삭제

- DELECTE TABLE과 TRUNCATE TABLE 은 로그를 남기지 않고 삭제
- DELECT TABLE
    - DML
    - Commit 이전 Rollback 가능
    - 사용자 Commit
    - 데이터를 모두 Delete 해도 사용했던 Storage 는 Release 되지 않음
    - 데이터만 삭제
- TRUNCATE TABLE
    - 테이블 자체가 삭제되는 것이 아니고 해당 테이블에 들어있던 모든 행들이 제거 되고 저장 공간을 재사용 가능하도록 해제함
    - DDL
    - Rollback 불가능
    - Auto Commit
    - 테이블을 최초 생성된 초기상태로 만듬
- DROP TABLE
    - 테이블 구조를 완전히 삭제
    - DDL
    - Rollback 불가능
    - Auto Commit
    - 테이블이 사용했던 Storage를 모두 Release
    - 테이블 정의 자체를 완전히 삭제함

### ■ 테이블에 입력된 데이터 조회

- ALL : Default 옵션이므로 별도로 표시하지 않아도 됨. 중복된 데이터가 있어도 모두 출력
- DISTINCT : 중복된 데이터가 있는 경우 1건으로 처리해서 출력함

### ■ 트랜잭션의 특징

- 원자성
    - 트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 남아있어야함
- 일관성
    - 트랜잭션이 실행 되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안됨
- 고립성
    - 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영행을 받아 잘못된 결과를 만들어서는 안됨
- 지속성
    - 트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장됨

### ■ 트랜잭션에 대한 격리성이 낮은 경우 발생하는 문제

- Dirty Read
    - 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 데이터를 읽는 것을 말함
- Non-Relpeatable Read
    - 한 트랜잭션 내에서 같은 쿼리를 두번 수행 했는데 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 현상
- Phantom Read
    - 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데 첫번째 쿼리에서 없던 유령 레코드가 두번째 쿼리에서 나타나는 현상

### ■ Oracle과 SQL Server 의 트랜잭션